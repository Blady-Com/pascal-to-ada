
-- p2ada
-- a source converter from Pascal MacOS to Ada
-- original version Martin C. Carlisle (November 1996)
-- mcc@cs.usafa.af.mil
-- http://www.usafa.af.mil/dfcs/bios/carlisle.html

-- extended for MacOS by Laurent Gasser (June 1997)
-- lga@sma.ch

with Pascal_Tokens, Pascal_Shift_Reduce, Pascal_Goto, Pascal_IO;
use  Pascal_Tokens, Pascal_Shift_Reduce, Pascal_Goto, Pascal_IO;
with Pascal_DFA, YYroutines, Text_IO, PascalHelp, YYerror;
use  Pascal_DFA, YYroutines, Text_IO;
with Ada.Characters.Handling;           use Ada.Characters.Handling;

--  Warning: This file is automatically generated by AYACC.
--           It is useless to modify it. Change the ".Y" & ".L" files instead.

with YY_Sizes;
-- ^ 14-Jan-2006 (GdM): configurable sizes instead of hard-coded
--   ones in AYACC's output

procedure YYParse is

   -- Rename User Defined Packages to Internal Names.
    package yy_goto_tables         renames
      Pascal_Goto;
    package yy_shift_reduce_tables renames
      Pascal_Shift_Reduce;
    package yy_tokens              renames
      Pascal_Tokens;
    package yy_io                  renames -- (+GdM 2008)
      Pascal_IO;

   use yy_tokens, yy_goto_tables, yy_shift_reduce_tables;

   procedure yyerrok;
   procedure yyclearin;


   package yy is

       -- the size of the value and state stacks
       --  Affects error 'Stack size exceeded on state_stack'
       stack_size : constant Natural := yy_sizes.stack_size; -- was 300, then 8192

       -- subtype rule         is natural;
       subtype parse_state  is natural;
       -- subtype nonterminal  is integer;

       -- encryption constants
       default           : constant := -1;
       first_shift_entry : constant :=  0;
       accept_code       : constant := -3001;
       error_code        : constant := -3000;

       -- stack data used by the parser
       tos                : natural := 0;
       value_stack        : array(0..stack_size) of yy_tokens.yystype;
       state_stack        : array(0..stack_size) of parse_state;

       -- current input symbol and action the parser is on
       action             : integer;
       rule_id            : rule;
       input_symbol       : yy_tokens.token:= Error;


       -- error recovery flag
       error_flag : natural := 0;
          -- indicates  3 - (number of valid shifts after an error occurs)

       look_ahead : boolean := true;
       index      : integer;

       -- Is Debugging option on or off
        DEBUG : constant boolean := FALSE;

    end yy;


    function goto_state
      (state : yy.parse_state;
       sym   : nonterminal) return yy.parse_state;

    function parse_action
      (state : yy.parse_state;
       t     : yy_tokens.token) return integer;

    pragma inline(goto_state, parse_action);


    function goto_state(state : yy.parse_state;
                        sym   : nonterminal) return yy.parse_state is
        index : integer;
    begin
        index := goto_offset(state);
        while  integer(goto_matrix(index).nonterm) /= sym loop
            index := index + 1;
        end loop;
        return integer(goto_matrix(index).newstate);
    end goto_state;


    function parse_action(state : yy.parse_state;
                          t     : yy_tokens.token) return integer is
        index      : integer;
        tok_pos    : integer;
        default    : constant integer := -1;
    begin
        tok_pos := yy_tokens.token'pos(t);
        index   := shift_reduce_offset(state);
        while integer(shift_reduce_matrix(index).t) /= tok_pos and then
              integer(shift_reduce_matrix(index).t) /= default
        loop
            index := index + 1;
        end loop;
        return integer(shift_reduce_matrix(index).act);
    end parse_action;

-- error recovery stuff

    procedure handle_error is
      temp_action : integer;
    begin

      if yy.error_flag = 3 then -- no shift yet, clobber input.
      if yy.debug then
          text_io.put_line("  -- Ayacc.YYParse: Error Recovery Clobbers " &
                   yy_tokens.token'image(yy.input_symbol));
      end if;
        if yy.input_symbol = yy_tokens.end_of_input then  -- don't discard,
        if yy.debug then
            text_io.put_line("  -- Ayacc.YYParse: Can't discard END_OF_INPUT, quiting...");
        end if;
        raise yy_tokens.syntax_error;
        end if;

            yy.look_ahead := true;   -- get next token
        return;                  -- and try again...
    end if;

    if yy.error_flag = 0 then -- brand new error
        if yy_io.Input_Line > 1 then
            yyerror("Syntax Error at line" & Text_IO.Count'Image(yy_io.Input_Line));
        else
            yyerror("Syntax Error at line 1 (or possibly later and the AFLex -E option was omitted).");
        end if;
    end if;

    yy.error_flag := 3;

    -- find state on stack where error is a valid shift --

    if yy.debug then
        text_io.put_line("  -- Ayacc.YYParse: Looking for state with error as valid shift");
    end if;

    loop
        if yy.debug then
          text_io.put_line("  -- Ayacc.YYParse: Examining State " &
               yy.parse_state'image(yy.state_stack(yy.tos)));
        end if;
        temp_action := parse_action(yy.state_stack(yy.tos), error);

            if temp_action >= yy.first_shift_entry then
                if yy.tos = yy.stack_size then
                    text_io.put_line("  -- Ayacc.YYParse: Stack size exceeded on state_stack");
                    raise yy_Tokens.syntax_error;
                end if;
                yy.tos := yy.tos + 1;
                yy.state_stack(yy.tos) := temp_action;
                exit;
            end if;

        Decrement_Stack_Pointer :
        begin
          yy.tos := yy.tos - 1;
        exception
          when Constraint_Error =>
            yy.tos := 0;
        end Decrement_Stack_Pointer;

        if yy.tos = 0 then
          if yy.debug then
            text_io.put_line("  -- Ayacc.YYParse: Error recovery popped entire stack, aborting...");
          end if;
          raise yy_tokens.syntax_error;
        end if;
    end loop;

    if yy.debug then
        text_io.put_line("  -- Ayacc.YYParse: Shifted error token in state " &
              yy.parse_state'image(yy.state_stack(yy.tos)));
    end if;

    end handle_error;

   -- print debugging information for a shift operation
   procedure shift_debug(state_id: yy.parse_state; lexeme: yy_tokens.token) is
   begin
       text_io.put_line("  -- Ayacc.YYParse: Shift "& yy.parse_state'image(state_id)&" on input symbol "&
               yy_tokens.token'image(lexeme) );
   end;

   -- print debugging information for a reduce operation
   procedure reduce_debug(rule_id: rule; state_id: yy.parse_state) is
   begin
       text_io.put_line("  -- Ayacc.YYParse: Reduce by rule "&rule'image(rule_id)&" goto state "&
               yy.parse_state'image(state_id));
   end;

   -- make the parser believe that 3 valid shifts have occured.
   -- used for error recovery.
   procedure yyerrok is
   begin
       yy.error_flag := 0;
   end yyerrok;

   -- called to clear input symbol that caused an error.
   procedure yyclearin is
   begin
       -- yy.input_symbol := yylex;
       yy.look_ahead := true;
   end yyclearin;


begin
    -- initialize by pushing state 0 and getting the first input symbol
    yy.state_stack(yy.tos) := 0;


    loop

        yy.index := shift_reduce_offset(yy.state_stack(yy.tos));
        if integer(shift_reduce_matrix(yy.index).t) = yy.default then
            yy.action := integer(shift_reduce_matrix(yy.index).act);
        else
            if yy.look_ahead then
                yy.look_ahead   := false;

                yy.input_symbol := yylex;
            end if;
            yy.action :=
             parse_action(yy.state_stack(yy.tos), yy.input_symbol);
        end if;


        if yy.action >= yy.first_shift_entry then  -- SHIFT

            if yy.debug then
                shift_debug(yy.action, yy.input_symbol);
            end if;

            -- Enter new state
            if yy.tos = yy.stack_size then
                text_io.put_line(" Stack size exceeded on state_stack");
                raise yy_Tokens.syntax_error;
            end if;
            yy.tos := yy.tos + 1;
            yy.state_stack(yy.tos) := yy.action;
              yy.value_stack(yy.tos) := yylval;

        if yy.error_flag > 0 then  -- indicate a valid shift
            yy.error_flag := yy.error_flag - 1;
        end if;

            -- Advance lookahead
            yy.look_ahead := true;

        elsif yy.action = yy.error_code then       -- ERROR

            handle_error;

        elsif yy.action = yy.accept_code then
            if yy.debug then
                text_io.put_line("  -- Ayacc.YYParse: Accepting Grammar...");
            end if;
            exit;

        else -- Reduce Action

            -- Convert action into a rule
            yy.rule_id  := -1 * yy.action;

            -- Execute User Action
            -- user_action(yy.rule_id);


                case yy.rule_id is

when 7 => -- #line 448
PascalHelp.package_name(1..
yy.value_stack(yy.tos).length) := 
yy.value_stack(yy.tos).text(1..
yy.value_stack(yy.tos).length);
    PascalHelp.package_name_length := 
yy.value_stack(yy.tos).length;

when 9 => -- #line 454
 PascalHelp.put_keyword("END ");
      PascalHelp.put(PascalHelp.package_name(1..PascalHelp.package_name_length));
      PascalHelp.put_line(";");
      PascalHelp.put_line(PascalHelp.blurb);
    

when 10 => -- #line 463
 PascalHelp.put_keyword("END ");
      PascalHelp.put(PascalHelp.package_name(1..PascalHelp.package_name_length));
      PascalHelp.put_line(";");
      PascalHelp.put_line(PascalHelp.blurb);
    

when 12 => -- #line 472
PascalHelp.Default_withs;

when 13 => -- #line 474

    PascalHelp.put_keyword("PACKAGE ");
    PascalHelp.put(PascalHelp.package_name(1..PascalHelp.package_name_length));
    PascalHelp.put_keyword(" IS");
    PascalHelp.put_line("");
    

when 14 => -- #line 481
PascalHelp.Stop_Export;

when 15 => -- #line 485
PascalHelp.Default_withs;

when 16 => -- #line 487
 PascalHelp.put_line("");
    PascalHelp.put_keyword("PACKAGE BODY ");
    PascalHelp.put(PascalHelp.package_name(1..PascalHelp.package_name_length));
    PascalHelp.put_keyword(" IS");
    PascalHelp.put_line("");
    PascalHelp.Default_instanciations;
    

when 20 => -- #line 501
PascalHelp.put_keyword("BEGIN");

when 26 => -- #line 514
PascalHelp.put_keyword("WITH");PascalHelp.Clear_Selection;

when 27 => -- #line 517
PascalHelp.put(';');
    PascalHelp.Put_translation_comment("place it before main procedure");

when 28 => -- #line 523

yyval.length := YYLength;
    
yyval.text(1..YYLength) := YYText;

when 48 => -- #line 564
PascalHelp.put(';'); PascalHelp.De_stack;

when 49 => -- #line 568
PascalHelp.put(';'); PascalHelp.De_stack;

when 52 => -- #line 574
PascalHelp.Default_withs;
     PascalHelp.put_keyword("PROCEDURE ");

when 53 => -- #line 577
PascalHelp.Stack_Ada_subprog( is_function=> False );
     PascalHelp.Put_keyword_line(" IS");
     PascalHelp.Default_instanciations;
    

when 55 => -- #line 586
PascalHelp.Default_withs;
     PascalHelp.put_keyword("PROCEDURE ");
     PascalHelp.Stack_Ada_subprog("I_love_Borland", is_function=> False);
     PascalHelp.Put_last_Ada_subprog_name;
     PascalHelp.put_keyword_line(" IS");
     PascalHelp.Default_instanciations;
    

when 57 => -- #line 599
PascalHelp.put_keyword("END ");
     PascalHelp.Put_last_Ada_subprog_name;
     PascalHelp.put(';');
     PascalHelp.Stop_Export; -- Export level 1 just before it is cleared
     PascalHelp.De_stack;
     PascalHelp.New_line;
     PascalHelp.put_line(PascalHelp.blurb);

when 61 => -- #line 615
PascalHelp.put_line(": Ada.Text_IO.File_Type;");

when 62 => -- #line 617
PascalHelp.put_line(": Ada.Text_IO.File_Type;");

when 63 => -- #line 622
PascalHelp.put(',');PascalHelp.Clear_Selection;

when 66 => -- #line 629
PascalHelp.put(',');

when 69 => -- #line 634
PascalHelp.Enter_var_name;

when 75 => -- #line 652
PascalHelp.Put("<<LABEL_"); PascalHelp.put(YYText); PascalHelp.put(">>");

when 76 => -- #line 656
PascalHelp.Put("LABEL_"); PascalHelp.put(YYText);

when 80 => -- #line 671
PascalHelp.DirectIO:= False;
     PascalHelp.Maybe_must_create_type:= True;
     PascalHelp.Set_variable_mark;

when 81 => -- #line 675
PascalHelp.Enter_var_name;

when 82 => -- #line 677
PascalHelp.put(';');

when 83 => -- #line 684
 PascalHelp.Maybe_must_create_type:= False;
      PascalHelp.DirectIO:= True;
      PascalHelp.Flush;
      PascalHelp.Empty;
      PascalHelp.put_keyword(": CONSTANT");
      PascalHelp.DirectIO := False;
      PascalHelp.Clear_type_denoter;
      PascalHelp.Reset_selection;
      

when 84 => -- #line 695

     PascalHelp.Give_variables_a_type;
     PascalHelp.DirectIO := True;
     IF 
yy.value_stack(yy.tos-1).vartype = boolean_type THEN
       PascalHelp.put(" Boolean := ");
     ELSIF 
yy.value_stack(yy.tos-1).vartype = character_type THEN
       PascalHelp.put(" Character := ");
     ELSIF 
yy.value_stack(yy.tos-1).vartype = string_type THEN
       PascalHelp.put(" String := ");
     ELSE
       PascalHelp.put(":= ");
     END IF;
     PascalHelp.flush;
     PascalHelp.empty;
    

when 85 => -- #line 713
PascalHelp.put(':');
     PascalHelp.Clear_type_denoter;
     PascalHelp.Reset_selection;

when 86 => -- #line 717
PascalHelp.Give_variables_a_type;
     PascalHelp.Maybe_must_create_type:= False;

when 87 => -- #line 720
PascalHelp.put(":=");
     PascalHelp.Reset_selection;

when 91 => -- #line 729
PascalHelp.put('(');PascalHelp.Clear_selection;

when 92 => -- #line 732
PascalHelp.put(')');

when 97 => -- #line 739
PascalHelp.put(',');PascalHelp.Clear_selection;

when 100 => -- #line 744
PascalHelp.put(',');PascalHelp.Clear_selection;

when 103 => -- #line 749
PascalHelp.put(',');PascalHelp.Clear_selection;

when 106 => -- #line 753
PascalHelp.put("=>");PascalHelp.Clear_selection;

when 108 => -- #line 756

yyval.vartype := 
yy.value_stack(yy.tos).vartype;

when 109 => -- #line 758
PascalHelp.Finish_Member_of; 
yyval.vartype:=boolean_type;

when 110 => -- #line 761

yyval.vartype := 
yy.value_stack(yy.tos).vartype;

when 111 => -- #line 762

yyval.vartype := other_type;

when 112 => -- #line 766
PascalHelp.Clear_selection;

when 114 => -- #line 770
PascalHelp.put('+');

when 116 => -- #line 771
PascalHelp.put('-');

when 118 => -- #line 772
PascalHelp.put_keyword("OR");

when 120 => -- #line 776

yyval.vartype := other_type; PascalHelp.Close_Eventual_Shift;

when 126 => -- #line 786
PascalHelp.put('(');
       PascalHelp.Clear_selection;

when 127 => -- #line 789
PascalHelp.put(')'); 
yyval.vartype := 
yy.value_stack(yy.tos-1).vartype;

when 128 => -- #line 790
PascalHelp.put_keyword("NOT");

when 130 => -- #line 794
DECLARE the_number : constant String := YYText;
         BEGIN
           PascalHelp.Put("Character'Val(" & the_number(2..
           the_number'last) & ")");
         END;

when 131 => -- #line 802
PascalHelp.PrintString(YYText);

when 134 => -- #line 807
PascalHelp.put('&');

when 136 => -- #line 811

yyval.vartype := other_type; PascalHelp.Select_litteral('N');

when 137 => -- #line 812
PascalHelp.Select_litteral('C');

when 138 => -- #line 813
if YYText="''''" then
       PascalHelp.Put("'''"); -- 10-Jan-2003
     else
       PascalHelp.Put(YYText);
     end if;
     
yyval.vartype := character_type;
    

when 139 => -- #line 820

yyval.vartype := character_type;PascalHelp.Select_litteral('C');

when 140 => -- #line 821

yyval.vartype := string_type;PascalHelp.Select_litteral('S');

when 141 => -- #line 824

yyval.vartype := 
yy.value_stack(yy.tos).vartype;

when 142 => -- #line 825

yyval.vartype := other_type;

when 143 => -- #line 826
PascalHelp.Select_litteral('C');

when 144 => -- #line 827
if YYText="''''" then
       PascalHelp.Put("'''"); -- 10-Jan-2003
     else
       PascalHelp.Put(YYText);
     end if;
     
yyval.vartype := character_type;
    

when 145 => -- #line 834

yyval.vartype := character_type; PascalHelp.Select_litteral('C');

when 146 => -- #line 835

yyval.vartype := string_type; PascalHelp.Select_litteral('S');

when 147 => -- #line 838
PascalHelp.put('+');

when 148 => -- #line 839
PascalHelp.put('-');

when 149 => -- #line 844
PascalHelp.Put_Decimal(YYText);
       
yyval.vartype := other_type;
       PascalHelp.Select_litteral('N');

when 150 => -- #line 848
PascalHelp.Put_Hexadecimal(YYText);
       PascalHelp.Select_litteral('N');

when 152 => -- #line 858
PascalHelp.Open_type_definition_part;

when 153 => -- #line 860
PascalHelp.Close_type_definition_part;

when 156 => -- #line 868
PascalHelp.put_keyword("TYPE ");
     PascalHelp.Maybe_must_add_NEW_to_type:= True; -- *only* here
    

when 157 => -- #line 872
PascalHelp.Open_Type_declaration;
     PascalHelp.Reset_selection;

when 158 => -- #line 875
PascalHelp.Close_type_declaration;

when 159 => -- #line 882
PascalHelp.Type_identifier; PascalHelp.Clear_Selection;

when 160 => -- #line 886
PascalHelp.put("(1 ..");PascalHelp.Denoter_is_String;

when 161 => -- #line 887
PascalHelp.put(")");

when 163 => -- #line 896

         if PascalHelp.Maybe_must_add_NEW_to_type then
           PascalHelp.DirectIO:= True;
           PascalHelp.Put_keyword(" RANGE ");
           PascalHelp.Flush;
           PascalHelp.Empty;
         elsif PascalHelp.Maybe_must_create_type then
           PascalHelp.DirectIO:= True;
           PascalHelp.Add(PascalHelp.tzpe);
           -- But the buffer is kept.
           PascalHelp.Put_keyword("type ");
           PascalHelp.Put_last(PascalHelp.tzpe);
           PascalHelp.Put_keyword(" IS RANGE ");
           declare
             id: constant String:= PascalHelp.Recent_identifier(1);
           begin
             PascalHelp.Put(id);
             PascalHelp.Shorten_buffer( id'length );
           end;
           PascalHelp.Just_after_TYPE_X_IS:= True;
         end if;
         PascalHelp.Put(" .. ");
         PascalHelp.Reset_selection;
        

when 164 => -- #line 921
if PascalHelp.Maybe_must_create_type then
           PascalHelp.Put(';');
           PascalHelp.Put_translation_comment("type definition needed in Ada");
           PascalHelp.Flush; -- The variable list comes now
           PascalHelp.Empty; -- ':' included
           PascalHelp.Put(' ');
           PascalHelp.Put_last(PascalHelp.tzpe);
         end if;

when 165 => -- #line 931
-- Maybe must add NEW (ex: "type t is NEW Integer")
       if PascalHelp.Maybe_must_add_NEW_to_type then
         PascalHelp.DirectIO:= True;
         PascalHelp.Put_keyword(" NEW ");
         PascalHelp.Flush;
         PascalHelp.Empty;
       -- No worry about creating a type here (VAR or CONST)
       elsif PascalHelp.Maybe_must_create_type then
         PascalHelp.DirectIO:= True;
         PascalHelp.Flush;
         PascalHelp.Empty;
       end if;

when 166 => -- #line 944
-- "type t is NEW String(1..200)"
       if PascalHelp.Maybe_must_add_NEW_to_type then
         PascalHelp.DirectIO:= True;
         PascalHelp.Put_keyword(" NEW ");
         PascalHelp.Flush;
         PascalHelp.Empty;
       -- No worry about creating a type here (VAR or CONST)
       else
         PascalHelp.No_need_of_type_creation;
       end if;

when 167 => -- #line 955
if PascalHelp.Maybe_must_add_NEW_to_type then
         PascalHelp.DirectIO:= True;
         PascalHelp.Flush;
         PascalHelp.Empty;
       end if;
      

when 173 => -- #line 973
PascalHelp.Open_eventual_type_creation;

when 174 => -- #line 975
PascalHelp.Close_eventual_type_creation;

when 180 => -- #line 987
PascalHelp.Put(" .. "); PascalHelp.Reset_selection;

when 181 => -- #line 989
PascalHelp.Put_translation_comment("A subtype should be created for that.");

when 185 => -- #line 995
if PascalHelp.Just_after_TYPE_X_IS then
         PascalHelp.put_keyword(" range ");
       end if;
       PascalHelp.Reset_selection;

when 187 => -- #line 1002
PascalHelp.put('(');PascalHelp.Clear_selection;

when 188 => -- #line 1004
PascalHelp.put(')');

when 189 => -- #line 1008
PascalHelp.put(" .. ");PascalHelp.Reset_selection;

when 195 => -- #line 1022
PascalHelp.No_need_of_type_creation;

when 197 => -- #line 1023
PascalHelp.Open_eventual_type_creation;

when 198 => -- #line 1025
PascalHelp.Close_eventual_type_creation;

when 199 => -- #line 1026
PascalHelp.No_need_of_type_creation;

when 201 => -- #line 1027
PascalHelp.No_need_of_type_creation;

when 208 => -- #line 1038
PascalHelp.put_keyword("ARRAY (");
     PascalHelp.Just_after_TYPE_X_IS:= False;
     PascalHelp.Open_array_dim( True );
    

when 209 => -- #line 1043
PascalHelp.put_keyword(") OF ");PascalHelp.Clear_selection;

when 210 => -- #line 1045
PascalHelp.Close_array_def;

when 211 => -- #line 1050
PascalHelp.put(',');
       PascalHelp.Open_array_dim( False );
       PascalHelp.Clear_Selection;

when 219 => -- #line 1085
PascalHelp.put_keyword(" RECORD ");
     PascalHelp.Open_record_def;
    

when 220 => -- #line 1091
if not PascalHelp.has_optional_semicolon then
       PascalHelp.put(';');
     end if;
     PascalHelp.has_optional_semicolon := FALSE;
     PascalHelp.Close_record_def;
    

when 221 => -- #line 1097
PascalHelp.put_keyword("END RECORD");

when 233 => -- #line 1123
 PascalHelp.put_keyword("TAGGED RECORD "); 

when 234 => -- #line 1127
 PascalHelp.put_keyword("NEW ");
       PascalHelp.Reset_selection;

when 235 => -- #line 1130
 PascalHelp.put_keyword(" WITH RECORD ");
       PascalHelp.Link_parent_of_object;

when 237 => -- #line 1136
PascalHelp.Remember_name_of_object(age => 0);
     PascalHelp.EnterObjectStruct;
     PascalHelp.Open_record_def;
    

when 238 => -- #line 1145
if not PascalHelp.has_optional_semicolon then
       PascalHelp.put(';');
     end if;
     PascalHelp.put_keyword("END RECORD");
     PascalHelp.has_optional_semicolon := FALSE;
     PascalHelp.Close_type_declaration;
     -- ^ OBJECT closes the declaration prematurely, before methods
     PascalHelp.Give_variables_a_type;
     PascalHelp.Close_record_def;
     PascalHelp.new_line;
    

when 239 => -- #line 1160
PascalHelp.LeaveObjectStruct;
    

when 242 => -- #line 1166
PascalHelp.put_keyword(" NULL");

when 243 => -- #line 1169
PascalHelp.put(';');

when 248 => -- #line 1176
PascalHelp.has_optional_semicolon := TRUE;

when 249 => -- #line 1180
PascalHelp.put(',');

when 252 => -- #line 1184
PascalHelp.Enter_field_name;

when 253 => -- #line 1187
PascalHelp.Set_field_mark(1);

when 254 => -- #line 1190
PascalHelp.Set_field_mark(2);
     PascalHelp.put(':');
     PascalHelp.Just_after_TYPE_X_IS:= False;
     PascalHelp.Reset_selection;

when 255 => -- #line 1195
PascalHelp.Give_variables_a_type;

when 256 => -- #line 1200
PascalHelp.put_keyword("CASE");
     PascalHelp.Set_field_mark(1);
     PascalHelp.Reset_selection;

when 257 => -- #line 1204
PascalHelp.put_keyword_line("IS");

when 258 => -- #line 1205
PascalHelp.put_keyword("WHEN ");

when 259 => -- #line 1207
PascalHelp.Put_empty_otherwise; PascalHelp.put_keyword("END CASE");

when 260 => -- #line 1212
PascalHelp.Set_field_mark(2);
       PascalHelp.Put('(' & PascalHelp.Recent_identifier(0) & ": ");
       PascalHelp.Reset_selection;

when 261 => -- #line 1216
PascalHelp.Give_variables_a_type;
       PascalHelp.Put(')');

when 263 => -- #line 1222
PascalHelp.put_keyword("WHEN ");
      PascalHelp.Reset_selection;

when 266 => -- #line 1228
PascalHelp.put(" => ");

when 267 => -- #line 1230
PascalHelp.Stack_optional_semicolon;

when 268 => -- #line 1232

    if not PascalHelp.has_optional_semicolon then
      PascalHelp.put(';');
    end if;
    PascalHelp.Recall_optional_semicolon;
    

when 270 => -- #line 1243
PascalHelp.put(" | ");
       PascalHelp.Reset_selection;

when 274 => -- #line 1254
PascalHelp.put("..");
       PascalHelp.Reset_selection;

when 276 => -- #line 1263
PascalHelp.put(',');PascalHelp.Reset_selection;

when 279 => -- #line 1268
PascalHelp.Enter_field_name;

when 281 => -- #line 1273
PascalHelp.put_keyword("array(");

when 282 => -- #line 1274
PascalHelp.put_keyword(") of "); PascalHelp.put("Boolean");

when 284 => -- #line 1281
if PascalHelp.Maybe_must_add_NEW_to_type then
         PascalHelp.Put_keyword("NEW ");
       end if;
       PascalHelp.Open_file_def;

when 286 => -- #line 1289
PascalHelp.Just_after_TYPE_X_IS:= False;

when 287 => -- #line 1291
PascalHelp.Close_file_def;
       PascalHelp.Create_Direct_IO(anonymous => False);

when 288 => -- #line 1293
PascalHelp.Clear_type_denoter; -- File of no type!
       PascalHelp.Close_file_def;
       PascalHelp.Create_Direct_IO(anonymous => True);

when 289 => -- #line 1300
PascalHelp.put_keyword("ACCESS ");
       PascalHelp.Open_pointer_def;
       PascalHelp.Reset_selection;

when 290 => -- #line 1304
PascalHelp.Close_pointer_def;
       PascalHelp.Put_Line(";");
       PascalHelp.Put( "procedure Dispose is new Ada.Unchecked_Deallocation(" &
         PascalHelp.Recent_identifier(0) & ", " &
         PascalHelp.Recent_identifier(1) & ')');
      

when 292 => -- #line 1315
PascalHelp.put_keyword("ACCESS PROCEDURE");

when 294 => -- #line 1319
PascalHelp.put_keyword("ACCESS FUNCTION");

when 295 => -- #line 1321
PascalHelp.put_keyword(" RETURN");PascalHelp.Clear_selection;

when 300 => -- #line 1339
PascalHelp.DirectIO:= False;
     PascalHelp.Maybe_must_create_type:= True;
     PascalHelp.Set_variable_mark;

when 301 => -- #line 1344
PascalHelp.put(':');
     PascalHelp.Clear_type_denoter;
     PascalHelp.Reset_selection;

when 302 => -- #line 1351
PascalHelp.Give_variables_a_type;
     PascalHelp.Maybe_must_create_type:= False;
     PascalHelp.put(';');

when 304 => -- #line 1357
PascalHelp.put_keyword(" renames ");

when 307 => -- #line 1361
PascalHelp.Put(":=");

when 314 => -- #line 1382
DECLARE
         tok : Token;
       BEGIN
         tok := YYLex;
         IF (tok = FORWARD_t) OR (tok=EXTERNAL_t) THEN
           PascalHelp.put_line(";");
         ELSE
           PascalHelp.put_keyword_line(" IS");
         END IF;
         UnYYLex(tok);
      END;

when 315 => -- #line 1394
PascalHelp.LeaveObjectStruct;

when 318 => -- #line 1406
PascalHelp.Put_Import_directive("C");

when 323 => -- #line 1414
PascalHelp.Memorize_identifier( YYtext(1..YYLength), YYtext(1..YYLength) );
    PascalHelp.Put_Export_directive;

when 325 => -- #line 1419
PascalHelp.Memorize_identifier( PascalHelp.Last_Ada_subprog_name, PascalHelp.Last_Ada_subprog_name );

when 326 => -- #line 1424
 PascalHelp.Memorize_identifier( YYtext(2..YYLength-1), YYtext(2..YYLength-1) );

when 327 => -- #line 1428
PascalHelp.put('(');
      PascalHelp.Var_Self_If_Object( other_params => True );
      PascalHelp.Set_variable_mark;
      PascalHelp.Clear_Selection;

when 328 => -- #line 1432
PascalHelp.put(')');

when 329 => -- #line 1435
PascalHelp.put(';'); PascalHelp.Set_variable_mark;PascalHelp.Clear_Selection;

when 337 => -- #line 1448
PascalHelp.put(':');PascalHelp.Clear_Selection;

when 342 => -- #line 1458
PascalHelp.Give_variables_a_type;

when 343 => -- #line 1463
PascalHelp.Put_translation_comment("passing option!");
     PascalHelp.Clear_Selection;

when 344 => -- #line 1469
PascalHelp.Put_VAR_param;PascalHelp.Clear_Selection;

when 346 => -- #line 1472
PascalHelp.Put_VAR_param; PascalHelp.put(" [Help! Typeless VAR!]");

when 348 => -- #line 1479
PascalHelp.Put_CONST_param;

when 350 => -- #line 1481
PascalHelp.Put_CONST_param; PascalHelp.put(" [Help! Typeless CONST!]");

when 351 => -- #line 1483
PascalHelp.De_stack;

when 352 => -- #line 1485
PascalHelp.De_stack;

when 353 => -- #line 1488
PascalHelp.DirectIO:= False;

when 354 => -- #line 1491
PascalHelp.DirectIO:= True;

when 355 => -- #line 1495
PascalHelp.Empty;
      PascalHelp.Remember_name_of_object(age => 0);

when 356 => -- #line 1498
PascalHelp.EnterObjectStruct;

when 358 => -- #line 1503
PascalHelp.Flush;
      PascalHelp.Empty;

when 362 => -- #line 1519
PascalHelp.put_keyword("PROCEDURE");

when 363 => -- #line 1521
PascalHelp.Stack_Ada_subprog( is_function=> False );

when 364 => -- #line 1523
PascalHelp.put_keyword("PROCEDURE");

when 365 => -- #line 1525
PascalHelp.Stack_Ada_subprog( is_function=> False );

when 366 => -- #line 1527
PascalHelp.put_keyword("PROCEDURE");

when 367 => -- #line 1529
PascalHelp.Stack_Ada_subprog( is_function=> False );

when 368 => -- #line 1533
DECLARE
         tok : Token;
       BEGIN
         tok := YYLex;
         IF (tok = FORWARD_t) OR (tok=EXTERNAL_t) THEN
           PascalHelp.put_line(";");
         ELSE
           PascalHelp.Open_function_body(type_ident => 
yy.value_stack(yy.tos-1).text(1..
yy.value_stack(yy.tos-1).length));
         END IF;
         UnYYLex(tok);
      END;

when 369 => -- #line 1545
PascalHelp.LeaveObjectStruct;

when 370 => -- #line 1549
PascalHelp.De_stack;

when 371 => -- #line 1550
PascalHelp.Close_function_block;

when 372 => -- #line 1554
PascalHelp.De_stack;

when 373 => -- #line 1555
PascalHelp.Close_procedure_block;

when 374 => -- #line 1558
PascalHelp.put_keyword("FUNCTION");

when 375 => -- #line 1560
PascalHelp.Stack_Ada_subprog( is_function=> True );

when 376 => -- #line 1562
PascalHelp.put_keyword(" RETURN ");PascalHelp.Clear_selection;

when 377 => -- #line 1564

yyval.length := 
yy.value_stack(yy.tos).length;
     
yyval.text := 
yy.value_stack(yy.tos).text;
     PascalHelp.Give_last_function_its_type;
    

when 379 => -- #line 1572
 PascalHelp.Var_Self_If_Object( other_params => False ); 

when 380 => -- #line 1576

yyval.length := 
yy.value_stack(yy.tos).length; 
yyval.text := 
yy.value_stack(yy.tos).text;

when 383 => -- #line 1584
PascalHelp.put_keyword(" null;");

when 384 => -- #line 1585
PascalHelp.put_keyword(" null; ");

when 385 => -- #line 1589
PascalHelp.function_result_flag:= True; -- *Only on this place*
       PascalHelp.Clear_null_flag;
       PascalHelp.Reset_selection;  -- In case of an assignment.
      

when 387 => -- #line 1594
PascalHelp.Clear_null_flag;
       PascalHelp.Reset_selection;  -- In case of a FOR i:= ...
      

when 392 => -- #line 1608
PascalHelp.put_keyword("END;");

when 403 => -- #line 1626
PascalHelp.function_result_flag:= False;

when 404 => -- #line 1627
PascalHelp.put(';');

when 405 => -- #line 1632
PascalHelp.function_result_flag:= False;

when 406 => -- #line 1633
PascalHelp.put(":=");
     PascalHelp.Reset_selection;

when 407 => -- #line 1636
PascalHelp.put(';');

when 408 => -- #line 1643
PascalHelp.Put_keyword("BEGIN");
             PascalHelp.Set_null_flag;
             PascalHelp.With_Self_If_Object;

when 409 => -- #line 1647
PascalHelp.End_Self_If_Object; PascalHelp.Put_eventual_null;

when 410 => -- #line 1651
PascalHelp.Put_keyword("BEGIN");
             PascalHelp.Set_null_flag;
             PascalHelp.With_Self_If_Object;
            

when 411 => -- #line 1657
PascalHelp.Put_eventual_null;
       PascalHelp.Put("[ Help! Please copy here the code in the ""finally"" part ]");
       PascalHelp.New_Line;
       PascalHelp.Put_keyword("EXCEPTION");
       PascalHelp.Put_translation_comment("** Begin of the ""finally"" part");
       PascalHelp.New_Line;
       PascalHelp.Put_keyword("when others =>");
       PascalHelp.New_Line;
       PascalHelp.Set_null_flag;
      

when 412 => -- #line 1668

       PascalHelp.New_Line;
       PascalHelp.Put_keyword("raise;");
       PascalHelp.Put_translation_comment("** End of the ""finally"" part, re-raise the exception");
      

when 413 => -- #line 1674
 PascalHelp.End_Self_If_Object;
      PascalHelp.Put_eventual_null;
      PascalHelp.Put_keyword("END;");
    

when 418 => -- #line 1686
PascalHelp.put_keyword(" null; ");

when 423 => -- #line 1696
PascalHelp.Set_null_flag;

when 424 => -- #line 1697
PascalHelp.Put_eventual_null;

when 425 => -- #line 1700
PascalHelp.put_keyword("LOOP");

when 426 => -- #line 1702
PascalHelp.put_keyword("   EXIT WHEN");
       PascalHelp.Reset_selection;

when 427 => -- #line 1704
PascalHelp.put_line(";"); PascalHelp.put_keyword("   END LOOP;");

when 428 => -- #line 1707
PascalHelp.put_keyword("WHILE");
       PascalHelp.Reset_selection;

when 429 => -- #line 1709
PascalHelp.put_keyword("LOOP");

when 430 => -- #line 1710
PascalHelp.put_keyword("END LOOP;");

when 431 => -- #line 1713
PascalHelp.put_keyword("FOR");

when 432 => -- #line 1714
PascalHelp.put_keyword(" IN");
              PascalHelp.DirectIO := False;
              PascalHelp.Reset_selection;
            

when 433 => -- #line 1719
PascalHelp.put_keyword("LOOP");

when 434 => -- #line 1721
PascalHelp.put_keyword("END LOOP;");

when 435 => -- #line 1725
 PascalHelp.WITH_header; 

when 436 => -- #line 1728

    PascalHelp.DirectIO:= True;
    PascalHelp.Put_keyword("BEGIN");
    

when 437 => -- #line 1733

    PascalHelp.Close_WITH;
    PascalHelp.New_Line;
    PascalHelp.Put_keyword("END;");
    PascalHelp.Put_translation_comment("end of WITH");
    

when 440 => -- #line 1747
PascalHelp.WITH_variable;

when 441 => -- #line 1750
PascalHelp.put_keyword("IF ");
       PascalHelp.Reset_selection;

when 442 => -- #line 1752
PascalHelp.put_keyword("THEN");

when 443 => -- #line 1754
PascalHelp.put_keyword("END IF;");

when 446 => -- #line 1759
PascalHelp.put_keyword("ELSE");

when 454 => -- #line 1769
PascalHelp.function_result_flag:= False;
       PascalHelp.RW.Clear_file_state;

when 455 => -- #line 1771
PascalHelp.RW.Complete;

when 456 => -- #line 1773
PascalHelp.function_result_flag:= False;
       PascalHelp.RW.Clear_file_state;

when 457 => -- #line 1775
PascalHelp.RW.Complete_Ln("New");

when 458 => -- #line 1777
PascalHelp.function_result_flag:= False;
       PascalHelp.RW.Clear_file_state;

when 459 => -- #line 1779
PascalHelp.RW.Complete;

when 460 => -- #line 1781
PascalHelp.function_result_flag:= False;
       PascalHelp.RW.Clear_file_state;

when 461 => -- #line 1783
PascalHelp.RW.Complete_Ln("Skip");

when 462 => -- #line 1787
PascalHelp.function_result_flag:= False;

when 463 => -- #line 1788
PascalHelp.put(';');

when 464 => -- #line 1792
PascalHelp.function_result_flag:= False;

when 465 => -- #line 1793
PascalHelp.put(';');

when 468 => -- #line 1802
PascalHelp.DirectIO:= False;
     PascalHelp.put("Put(");
     PascalHelp.RW.parameter:= True;
     PascalHelp.Reset_selection;

when 469 => -- #line 1806
PascalHelp.Put("); ");

when 471 => -- #line 1811
PascalHelp.RW.Separate_arguments("Put");

when 474 => -- #line 1817
PascalHelp.RW.Store_file_state;

when 475 => -- #line 1819
 PascalHelp.RW.Store_file_state; PascalHelp.put(',');
       PascalHelp.Reset_selection;

when 477 => -- #line 1825
PascalHelp.DirectIO:= False;
     PascalHelp.put("Get(");
     PascalHelp.RW.parameter:= True;
     PascalHelp.Reset_selection;

when 478 => -- #line 1829
PascalHelp.Put("); ");

when 480 => -- #line 1834
PascalHelp.RW.Separate_arguments("Get");

when 483 => -- #line 1839
PascalHelp.RW.Store_file_state;

when 485 => -- #line 1842
PascalHelp.put(',');
       PascalHelp.Reset_selection;

when 486 => -- #line 1844
PascalHelp.put(",0");

when 487 => -- #line 1848
PascalHelp.function_result_flag:= False;
     PascalHelp.Put("Put");

when 488 => -- #line 1849
PascalHelp.put(';');

when 489 => -- #line 1853
PascalHelp.put('(');
     PascalHelp.RW.Clear_file_state;
     -- 2-Jun-2003: meaningless for STR, but read by WRITE's params.
    

when 490 => -- #line 1857
PascalHelp.put(',');
       PascalHelp.Reset_selection;

when 491 => -- #line 1859
PascalHelp.put(')');

when 492 => -- #line 1864
PascalHelp.Stack_selection;
     PascalHelp.Stack_Postfixed_alias;
    

when 493 => -- #line 1869
PascalHelp.Recall_Postfixed_alias;
     PascalHelp.Destack_selection;
     

when 494 => -- #line 1875
PascalHelp.put(','); PascalHelp.Clear_selection;

when 497 => -- #line 1882
PascalHelp.DirectIO:= False;
       PascalHelp.Reset_selection;

when 498 => -- #line 1885
PascalHelp.Inc_dec_part_1;

when 499 => -- #line 1888
PascalHelp.Inc_dec_part_2(" - ");

when 500 => -- #line 1893
PascalHelp.DirectIO:= False;
       PascalHelp.Reset_selection;

when 501 => -- #line 1896
PascalHelp.Inc_dec_part_1;

when 502 => -- #line 1899
PascalHelp.Inc_dec_part_2(" + ");

when 504 => -- #line 1902
PascalHelp.Put('1');

when 505 => -- #line 1904
PascalHelp.Put('(');
       PascalHelp.Reset_selection;

when 506 => -- #line 1905
PascalHelp.Put(')');

when 507 => -- #line 1910
PascalHelp.Reset_selection;

when 508 => -- #line 1912
PascalHelp.Conclude_allocator;

when 509 => -- #line 1915
PascalHelp.Put(';');

when 510 => -- #line 1920
PascalHelp.Put('(');

when 511 => -- #line 1922
PascalHelp.Put(')');

when 513 => -- #line 1927
PascalHelp.Put(',');

when 519 => -- #line 1940
PascalHelp.Put_keyword("return [from] ");
       PascalHelp.Reset_selection;

when 520 => -- #line 1944
PascalHelp.Put(';');
     PascalHelp.Put_translation_comment("!Help! CWP's EXIT(...)");
     

when 521 => -- #line 1949
PascalHelp.put_keyword("GOTO");

when 522 => -- #line 1950
PascalHelp.put("; ");

when 523 => -- #line 1953
PascalHelp.put_keyword("CASE ");
       PascalHelp.Reset_selection;

when 524 => -- #line 1955
PascalHelp.put_keyword_line(" IS ");

when 525 => -- #line 1956
PascalHelp.put_keyword("WHEN ");

when 526 => -- #line 1957
PascalHelp.put_keyword_line("END CASE;");

when 530 => -- #line 1967
PascalHelp.Set_null_flag;

when 531 => -- #line 1967
PascalHelp.Put_eventual_null;

when 532 => -- #line 1968
PascalHelp.Put_empty_otherwise;

when 534 => -- #line 1974
PascalHelp.put_keyword("WHEN ");

when 537 => -- #line 1978
PascalHelp.put("=>");

when 539 => -- #line 1982
PascalHelp.put_keyword("WHEN OTHERS =>");

when 541 => -- #line 1983
PascalHelp.put_keyword("WHEN OTHERS =>");

when 543 => -- #line 1984
PascalHelp.put_keyword("WHEN OTHERS =>");

when 547 => -- #line 1991
 PascalHelp.Direction_To;
                         PascalHelp.Reset_selection; 

when 548 => -- #line 1993
 PascalHelp.Direction_Downto;
                         PascalHelp.Reset_selection; 

when 549 => -- #line 1996
 PascalHelp.Close_eventual_Downto; 

when 551 => -- #line 2000
PascalHelp.Clear_selection;

when 553 => -- #line 2005
PascalHelp.Finish_Member_of;

when 559 => -- #line 2017
PascalHelp.Close_Eventual_Shift;

when 560 => -- #line 2021
PascalHelp.put("System.Address_To_Access_Conversions.To_Address(");
       PascalHelp.Clear_selection;

when 561 => -- #line 2023
PascalHelp.put_line(")");

when 565 => -- #line 2027
PascalHelp.put('(');PascalHelp.Clear_selection;

when 566 => -- #line 2029
PascalHelp.put(')');

when 567 => -- #line 2031
PascalHelp.put_keyword("NOT");PascalHelp.Clear_selection;

when 572 => -- #line 2049
null;

when 574 => -- #line 2051
PascalHelp.put('.');

when 578 => -- #line 2064
PascalHelp.put('(');
       PascalHelp.Lost:= PascalHelp.Lost_in_selection;
       PascalHelp.Select_one_dimension;
       if not (PascalHelp.Lost or PascalHelp.First_dim_selected) then
         PascalHelp.Put_translation_comment("Write (a,b) instead of (a)(b) !");
       end if;
       

when 579 => -- #line 2073
PascalHelp.put(')');PascalHelp.Close_one_dimension;

when 580 => -- #line 2079
PascalHelp.Close_one_dimension;
       PascalHelp.Lost:= PascalHelp.Lost_in_selection;
       PascalHelp.Select_one_dimension;
       -- ^as if [a][b] == [a,b], avoids having to
       --  remember to close > 1 dimensions
       if PascalHelp.First_dim_selected and not PascalHelp.Lost then
         PascalHelp.Put(")("); -- In Pascal, [a][b] == [a,b], not in Ada
       else
         PascalHelp.Put(',');
       end if;
      

when 585 => -- #line 2098
PascalHelp.Put_translation_comment("special array - mem ?");

when 586 => -- #line 2106
PascalHelp.put(".all"); PascalHelp.Select_pointed;

when 587 => -- #line 2114
PascalHelp.Put_Decimal(YYText);

when 588 => -- #line 2115
PascalHelp.Put_Hexadecimal(YYText);

when 589 => -- #line 2120
PascalHelp.put("(");

when 590 => -- #line 2122
PascalHelp.put_keyword("OTHERS");
       PascalHelp.put(" => False) ");

when 592 => -- #line 2127
PascalHelp.put(" => True, ");

when 594 => -- #line 2132
PascalHelp.put('|');

when 597 => -- #line 2136
PascalHelp.put("..");

when 600 => -- #line 2141
PascalHelp.Clear_Selection;

when 601 => -- #line 2144
PascalHelp.put('+');

when 602 => -- #line 2145
PascalHelp.put('-');

when 603 => -- #line 2146
PascalHelp.put_keyword(" OR ");

when 604 => -- #line 2147
PascalHelp.put_keyword(" OR ELSE ");

when 605 => -- #line 2148
PascalHelp.put_keyword(" OR ELSE ");

when 606 => -- #line 2149
PascalHelp.put_keyword(" XOR ");

when 607 => -- #line 2152
PascalHelp.Clear_Selection;

when 608 => -- #line 2155
PascalHelp.put('*');

when 609 => -- #line 2156
PascalHelp.put('/');

when 610 => -- #line 2157
PascalHelp.put("  /  ");

when 611 => -- #line 2158
PascalHelp.Put_MOD;

when 612 => -- #line 2159
PascalHelp.put_keyword(" AND ");

when 613 => -- #line 2160
PascalHelp.put_keyword(" AND THEN ");

when 614 => -- #line 2161
PascalHelp.put(" * (2 ** "); PascalHelp.Open_Shift;

when 615 => -- #line 2162
PascalHelp.put(" / (2 ** "); PascalHelp.Open_Shift;

when 616 => -- #line 2163
PascalHelp.put_keyword(" AND THEN ");

when 617 => -- #line 2164
PascalHelp.put("**");

when 618 => -- #line 2167
PascalHelp.Clear_Selection;

when 619 => -- #line 2170
PascalHelp.put('=');

when 620 => -- #line 2171
PascalHelp.put("/=");

when 621 => -- #line 2172
PascalHelp.put('<');

when 622 => -- #line 2173
PascalHelp.put('>');

when 623 => -- #line 2174
PascalHelp.put("<=");

when 624 => -- #line 2175
PascalHelp.put(">=");

when 625 => -- #line 2176
PascalHelp.DirectIO:= False;

when 626 => -- #line 2180
PascalHelp.DirectIO:= True;
       PascalHelp.member_of:= True;
       PascalHelp.put_keyword("AND");

when 627 => -- #line 2185

      declare
        id: constant String:= YYtext(1..YYLength);
      begin
        PascalHelp.Memorize_identifier( id, id );
        -- NB: no Ada alias, the programmer want THIS name!
        -- But PascalHelp will add a prefix to Ada's id in
        -- case it hits a keyword
        
yyval.length:= id'length; 
yyval.text(1..id'length):=id;
        PascalHelp.Put( PascalHelp.Recent_identifier(0) );
        -- = id, plus an eventual keyword-avoiding prefix
      end;
      

when 629 => -- #line 2201

      declare
        Pascal_id: constant String:= YYtext(1..YYLength);
        Up_Pas_id: constant String:= To_Upper(Pascal_id);
      begin
        PascalHelp.Select_identifier( Pascal_id );
        declare
          Ada_id : constant String:= PascalHelp.Find_alias( Pascal_id );
        begin
          PascalHelp.Memorize_identifier( Ada_id, Pascal_id );
          IF PascalHelp.function_result_flag and then
             PascalHelp.Function_in_stack( Pascal_id ) THEN
             PascalHelp.put("Result_");
          END IF;

          
yyval.length:= Ada_id'length; 
yyval.text(1..Ada_id'length):=Ada_id;

          if Up_Pas_id="NIL" then
            PascalHelp.Put_keyword(Ada_id); -- "null" is a keyword
          elsif Ada_id = "return" then -- Was an unmasked "exit"
            PascalHelp.function_result_flag:= False;
            PascalHelp.Put_keyword("return");
            if PascalHelp.Is_last_a_function then
              PascalHelp.Put(" Result_"); PascalHelp.Put_last_Ada_subprog_name;
            end if;
          elsif Ada_id = "exit" then
            PascalHelp.Put_keyword("exit");
          elsif To_Upper(Ada_id) = Up_Pas_id and then Up_Pas_id /= "ABS" then
            -- Not Adaliased, but maybe the Pascal id is an Ada keyword.
            -- For example, an redefined "Exit" function.
            -- In that case, Memorize_identifier above has put a prefix to Ada_id.
            PascalHelp.Put(PascalHelp.Recent_identifier(0));
          else
            PascalHelp.Put(Ada_id);
          end if;
          -- To be absolutely correct, we should grab the type of the
          -- possibly masked identifier!
          if Up_Pas_id = "TRUE" or Up_Pas_id = "FALSE" then
            
yyval.vartype := boolean_type;
          else
            
yyval.vartype := other_type;
          end if;
        end;
      end;
      

when 631 => -- #line 2250
PascalHelp.Put_masked_keyword("str"); 

when 632 => -- #line 2252
PascalHelp.Put_masked_keyword("dec"); 

when 633 => -- #line 2253
PascalHelp.Put_masked_keyword("inc"); 

when 634 => -- #line 2254
PascalHelp.Put_masked_keyword("forward"); 

when 635 => -- #line 2255
PascalHelp.Put_masked_keyword("external"); 

                    when others => null;
                end case;


            -- Pop RHS states and goto next state
            yy.tos      := yy.tos - rule_length(yy.rule_id) + 1;
            if yy.tos > yy.stack_size then
                text_io.put_line(" Stack size exceeded on state_stack");
                raise yy_Tokens.syntax_error;
            end if;
            yy.state_stack(yy.tos) := goto_state(yy.state_stack(yy.tos-1) ,
                                 get_lhs_rule(yy.rule_id));

              yy.value_stack(yy.tos) := yyval;

            if yy.debug then
                reduce_debug(yy.rule_id,
                    goto_state(yy.state_stack(yy.tos - 1),
                               get_lhs_rule(yy.rule_id)));
            end if;

        end if;


    end loop;


end yyparse;
